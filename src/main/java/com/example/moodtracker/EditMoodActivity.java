package com.example.moodtracker;

import android.arch.lifecycle.Observer;
import android.arch.lifecycle.ViewModelProviders;
import android.content.Intent;
import android.databinding.DataBindingUtil;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;

import android.widget.Toast;

import com.example.moodtracker.MoodDatabase.DateConverter;
import com.example.moodtracker.MoodDatabase.MoodDatabase;
import com.example.moodtracker.MoodDatabase.MoodEntry;
import com.example.moodtracker.Utilities.AppExecutors;
import com.example.moodtracker.Utilities.Constants;
import com.example.moodtracker.Utilities.EditTextSoftKeyListener;
import com.example.moodtracker.Utilities.MoodUtilities;
import com.example.moodtracker.databinding.ActivityMoodRegisterBinding;

public class EditMoodActivity extends AppCompatActivity {

    public static final String TAG = EditMoodActivity.class.getName();

    public boolean inUpdateMode = false;
    private final String SAVED_INSTANCE_STATE_KEY_UPDATE_MODE = "inUpdateMode";

    // The ID of the mood entry.
    // Should be assigned a valid value on the opening this activity.
    // If it remains -1 that means there is no valid MoodEntry to be loaded
    int mMoodEntryId = -1;

    // This variable stores the ID of the selected mood
    int mSelectedMood = 0;

    // This variable holds the notes added by the user to the actual day's mood
    String mMoodNotes = "";

    Long mMoodDateTime;

    // This boolean shows if there are any notes added by the user that needs to be saved
    boolean mNotesAdded = false;

    // This is the MoodEntry to be showed/modified
    MoodEntry mMoodEntry;

    // The instance of the data binding class
    // A binding class is autogenerated for each layout file.
    ActivityMoodRegisterBinding mBinding;

    // This variable holds the single instance of our database
    private MoodDatabase mMoodDatabase;

    // This variable holds the number of rows that were successfully updated in the database
    private int mUpdatedRows;

    // LISTENERS

    // todo: add this listener (and the same one in MoodRegisterActivity) to utilities!
    // todo: delete this code snippet if not needed any more.
    // This listener is notified when a mood icon is clicked
    // When a mood is clicked the UI shows an indicator around the selected mood icon

    View.OnClickListener mMoodIconListener = new View.OnClickListener() {
        @Override
        public void onClick(View moodIcon) {

            // Check if any mood was selected previously and clean up before saving the new mood state
            if (mSelectedMood != 0) {
                MoodUtilities.cleanUpSelectedMood(mSelectedMood, mBinding);
                mSelectedMood = 0;
            }

            // Register which mood was selected by the user
            mSelectedMood = MoodUtilities.registerSelectedMood(moodIcon);

            // and put a sign on the selected mood in the UI
            MoodUtilities.showSelectedMood(mSelectedMood, mBinding);
        }
    };



    // This listener is notified when the Modify/Update button is clicked
    // This listener is responsible to invoke the modify/update function when the user clicks on the show mood history button
    // The function of the button changes based on the mode (read only or update) we are in.
    View.OnClickListener mModifyUpdateButtonListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.d(TAG, "onClick: mModifyUpdateButtonListener. inUpdateMode = " + inUpdateMode);
            if (inUpdateMode) {
                // This means we are in Update mode, so when the user clicks on the button we invoke the update MoodEntry function
                updateMood();
            } else {
                switchUiToUpdateMode();
            }
        }
    };

    // This listener is notified when the Cancel/Back to Mood List button is clicked
    // and it is responsible to invoke the cancel/back to list function when the user clicks on the button.
    // The function of the button is always the same, but the label of the button changes based on the input mode we are in.
    View.OnClickListener mCancelBackToListListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            showMoodHistory();
        }
    };

    // This listener is notified when the Delete button is clicked.
    // This button is available only after the user clicked on the Modify button
    View.OnClickListener mDeleteMoodListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.d(TAG, "onClick: mDeleteMoodListener is activated");
            Log.d(TAG, "onClick: will delete MoodEntry ID " + mMoodEntryId);
            deleteMoodWithId(mMoodEntryId);

            showMoodHistory();
            Toast.makeText(getApplicationContext(), "Deleted.", Toast.LENGTH_SHORT).show();
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Adapt the components of the UI to the activity using data binding
        bindData();

        // Create (or get) the instance of the database
        // We need the application context to see if the db was already created by another activity
        // todo:  Database instance should be provided by ViewModel!!! - lsd: LiveData & ViewModel in FÃœZETBE
        mMoodDatabase = MoodDatabase.getDatabase(getApplicationContext());


        // todo: refactor code to prevent crash when mood ID is invalid

        Intent intent = getIntent();
        String intentKey = Constants.INTENT_EXTRA_MOOD_ID_KEY;

        if (intent != null && intent.hasExtra(intentKey)) {
            mMoodEntryId = intent.getExtras().getInt(intentKey, -1);

            // check if the mood entry ID is valid
            if (mMoodEntryId == -1) {
                Log.w(TAG, "onCreate: MoodEntry ID is not valid! ");
            }

            EditMoodViewModelFactory factory = new EditMoodViewModelFactory(mMoodDatabase, mMoodEntryId);

            final EditMoodViewModel viewModel = ViewModelProviders.of(this, factory).get(EditMoodViewModel.class);

            viewModel.getMoodEntry().observe(this, new Observer<MoodEntry>() {
                @Override
                public void onChanged(@Nullable MoodEntry moodEntry) {

                    viewModel.getMoodEntry().removeObserver(this);

                    // we can update the UI here if necessary - pl:
                    // populateUI(moodEntry);

                    // Retrieve the data only if the MoodEntry is not null
                    if (moodEntry != null) {

                        populateUi(moodEntry);
                    } else {
                        Log.d(TAG, "onCreate: onChanged MoodEntry, new MoodEntry is null! ");
                    }
                }
            });
        }
        if (inUpdateMode){
            Log.d(TAG, "onCreate: inUpdateMode = " + inUpdateMode + ". Switch UI to Update Mode.");
            switchUiToUpdateMode();
        }

    }

    private void populateUi(MoodEntry entry) {

        if (entry == null) {
            Log.d(TAG, "populateUi: MoodEntry is null.");
            return;
        }

        mMoodEntry = entry;

        // assign the correct value to mSelectedMood
        mSelectedMood = mMoodEntry.getMoodId();
        Log.d(TAG, "onCreate: retrieved mood from MoodEntry. mSelectedMood = " + mSelectedMood);

        // Display on the UI the mood belonging to the MoodEntry
        MoodUtilities.showSelectedMood(mSelectedMood, mBinding);

        // Extract the saved text from the database
        //  assign the correct text to mMoodNotes and show it on the UI
        mMoodNotes = mMoodEntry.getNotes();
        mBinding.editModeNotesTextView.setText(mMoodNotes);

        mMoodDateTime = mMoodEntry.getTimeOfMood();
        mBinding.dateOfEntry.setText(DateConverter.timeStampToDateString(mMoodDateTime));
    }

    private void bindData() {
        // Initialize/get access to the data binding class
        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_mood_register);

        // adapt texts and views of the layout to the edit mood activity
        mBinding.modifySaveButton.setText(R.string.buttonModifyMood);
        mBinding.dateOfEntry.setVisibility(View.VISIBLE);
        mBinding.editTextNotes.setVisibility(View.GONE);
        mBinding.editModeNotesTextView.setVisibility(View.VISIBLE);
        mBinding.moodHistoryButton.setText(R.string.buttonBackToMoodHistory);

        // set the listeners on the buttons to invoke the functions when the user clicks on them.
        mBinding.modifySaveButton.setOnClickListener(mModifyUpdateButtonListener);
        mBinding.moodHistoryButton.setOnClickListener(mCancelBackToListListener);
        mBinding.editTextNotes.setOnEditorActionListener(new EditTextSoftKeyListener(EditMoodActivity.this));
    }

    // Save the update/modify mode state
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        outState.putBoolean(SAVED_INSTANCE_STATE_KEY_UPDATE_MODE, inUpdateMode);
        outState.putInt(Constants.SAVED_INSTANCE_STATE_MOOD_ID_KEY, mSelectedMood);
        outState.putString(Constants.SAVED_INSTANCE_STATE_NOTES_KEY, mMoodNotes);
        super.onSaveInstanceState(outState);
    }

    // Restore the modify/update mode state
    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        inUpdateMode = savedInstanceState.getBoolean(SAVED_INSTANCE_STATE_KEY_UPDATE_MODE);
        mSelectedMood = savedInstanceState.getInt(Constants.SAVED_INSTANCE_STATE_MOOD_ID_KEY);
        mMoodNotes = savedInstanceState.getString(Constants.SAVED_INSTANCE_STATE_NOTES_KEY);
    }

    /**
     * When the user presses the update button, this method extracts the data from the UI and updates the database.
     */
    public void updateMood() {
        mMoodNotes = mBinding.editTextNotes.getText().toString();

        //Todo: refactor code to save the update time separated
        Long timeStampLong = System.currentTimeMillis();

        final MoodEntry updatedEntry = new MoodEntry(mSelectedMood, timeStampLong, mMoodNotes);
        Log.d(TAG, "updateMood: mMoodEntryId = " + mMoodEntryId);
        updatedEntry.setEntryId(mMoodEntryId);

        // Execute this method on a background thread, as database operation might take a long time thus blocking the UI
        AppExecutors.getInstance().diskIO().execute(new Runnable() {
            @Override
            public void run() {
                final int updatedRows = mMoodDatabase.moodDao().updateMoodEntry(updatedEntry);

                AppExecutors.getInstance().mainThread().execute(new Runnable() {
                    @Override
                    public void run() {
                        refreshUpdatedRows(updatedRows);
                        if (mUpdatedRows > 0) {
                            Log.d(TAG, "updateMood: database is updated successfully");
                            Toast.makeText(getApplicationContext(), "Updated.", Toast.LENGTH_SHORT).show();
                            showMoodHistory();
                        } else {
                            Log.d(TAG, "updateMood: failed to update the data");
                        }
                    }
                });
                // close the activity and go back to the parent activity
                finish();
            }
        });
    }


    public void deleteMoodWithId(int entryId) {
    // This method of the MoodDao runs automatically off the main thread by Room.
        int deletedRows = mMoodDatabase.moodDao().deleteMoodEntryById(entryId);
        if (deletedRows > 0) {
            Log.d(TAG, "deleteMood: entry is deleted successfully");
        } else {
            Log.d(TAG, "deleteMood: failed to delete the entry");
        }
    }

    /**
     * This method opens up a new activity to show the list of saved moods
     **/
    public void showMoodHistory() {
        Intent i = new Intent(getApplicationContext(), MoodHistoryActivity.class);
        startActivity(i);
    }


    // This method adjusts the layout so that the user can modify the MoodEntry
    public void switchUiToUpdateMode() {

        // Modify the layout to switch from showing the specific mood entry to Modify entry mode
        mBinding.dateOfEntry.setVisibility(View.INVISIBLE);
        mBinding.editModeNotesTextView.setVisibility(View.GONE);
        mBinding.editTextNotes.setVisibility(View.VISIBLE);
        mBinding.modifySaveButton.setText(getResources().getString(R.string.buttonUpdateMood));
        mBinding.moodHistoryButton.setText(R.string.buttonCancelModification);
        mBinding.deleteButton.setVisibility(View.VISIBLE);

        // DISPLAY THE MOOD ENTRY ON THE UI
        mBinding.editTextNotes.setText(mMoodNotes);

        // SET LISTENERS ON VIEWS

        // Set a new listener on the Delete button to delete the current entry from the database when the button is clicked.
        mBinding.deleteButton.setOnClickListener(mDeleteMoodListener);

        // set the listener on the mood icons so that it registers if an icon is clicked
        mBinding.iconBad.setOnClickListener(mMoodIconListener);
        mBinding.iconGood.setOnClickListener(mMoodIconListener);
        mBinding.iconNeutral.setOnClickListener(mMoodIconListener);
        mBinding.iconVeryBad.setOnClickListener(mMoodIconListener);
        mBinding.iconVeryGood.setOnClickListener(mMoodIconListener);

        // set a listener on the EditText field to know if there are any notes to be saved
        mBinding.editTextNotes.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mNotesAdded = true; // this boolean indicates that there might be some notes that we have to save.
            }
        });

        // indicate that we switched from "read only" mode to update mode.
        inUpdateMode = true;
    }

    // This helper method refreshes the global variable that holds the number of the successfully updated rows in the database
    private void refreshUpdatedRows(int updatedRows) {
        this.mUpdatedRows = updatedRows;
    }

}
